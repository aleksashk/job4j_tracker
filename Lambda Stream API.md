
## FP Labmda Stream API

+ [1. Что такое lamdba выражение](#Что-такое-lamdba-выражение)
+ [2. Что такое функциональные интерфейсы](#Что-такое-функциональные-интерфейсы)
+ [3. Перечислите функциональные интерфейсы из пакета java.util.function](#перечислите-функциональные-интерфейсы-из-пакета-javautilfunction)
+ [4. Что такое функции высшего порядка](#Что-такое-функции-высшего-порядка)
+ [5. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка](#Какие-функциональные-интерфейсы-из-пакета-javautilfunction-поддерживают-функции-высшего-порядка)
+ [6. Что такое ссылки на методы](#Что-такое-ссылки-на-методы)
+ [7. Что такое ссылки на конструкторы](#Что-такое-ссылки-на-конструкторы)
+ [8. Расскажите о зоне видимости переменных в lamdba - выражениях](#Расскажите-о-зоне-видимости-переменных-в-lamdba---выражениях)
+ [9. Как быть в ситуации, если внутри lamdba - выражении операторы могут выкинуть исключение](#Как-быть-в-ситуации-если-внутри-lamdba---выражении-операторы-могут-выкинуть-исключение)
+ [10. Что такое Stream API](#Что-такое-Stream-API)
+ [11. Расскажите, как шаблон проектирования используется внутри Stream API](#Расскажите-как-шаблон-проектирования-используется-внутри-Stream-API)
+ [12. Что делает метод filter](#Что-делает-метод-filter)
+ [13. Что делает метод map](#Что-делает-метод-map)
+ [14. Что делает метод flatMap](#Что-делает-метод-flatMap)
+ [15. Что делает метод collect](#Что-делает-метод-collect)
+ [16. Что делает метод reduce](#Что-делает-метод-reduce)
+ [17. Что делает метод findFirst](#Что-делает-метод-findFirst)
+ [18. Возможно ли прервать выполнение потока по аналогии с break](#Возможно-ли-прервать-выполнение-потока-по-аналогии-с-break)
+ [19. Возможно ли пропустить элемент потока по аналогии с continue](#Возможно-ли-пропустить-элемент-потока-по-аналогии-с-continue)
+ [20. Что такое Optional](#Что-такое-Optional)
+ [21. Перечислите методы Optional](#Перечислите-методы-Optional)
+ [22. Расскажите про фабричные методы List.of, Set.of, Map.of](#Расскажите-про-фабричные-методы-Listof-Setof-Mapof)
+ [23. Для чего используется ключевое слово var](#Для-чего-используется-ключевое-слово-var)
+ [24. В какие случаях можно использовать var](#В-какие-случаях-можно-использовать-var)
+ [Шпаргалка Java программиста 4. Java Stream API](https://habr.com/ru/company/luxoft/blog/270383/)

## Что такое lamdba выражение
Лямбда-выражение представляет собой блок кода, 	который можно передать в другое место, поэтому он может быть выполнен позже,
один или несколько раз. По сути это функция, которая существует, но в данный момент времени не может быть вычислена.

По существу является анонимным (безымянным) методом, который реализует метод, определенный в функциональном интерфейсе.

(входящие параметры через запятую без указания типа) -> {
    операторы;
    return вычисленное значение;
}
Если функция не принимает параметры, то указываем пустые скобки. Если не возвращает, то не указываем return.

подробнее https://www.ibm.com/developerworks/ru/library/j-java8lambdas/index.html
	
[к оглавлению](#FP-Labmda-Stream-API)

## Что такое функциональные интерфейсы
Это интерфейс, который содержит только 1 абстрактный метод. Основное назначение – использование в лямбда выражениях и method reference.
Такой интерфейс описываем классическую математическую функцию.
Таким образом функциональный интерфейс может содержать так же default и static методы.
К функциональному интерфейсу можно добавить аннотацию 
```java 
@FunctionalInterface 
```

[к оглавлению](#FP-Labmda-Stream-API)

## Перечислите функциональные интерфейсы из пакета java.util.function

[Подробней](https://metanit.com/java/tutorial/9.3.php)
 
Consumer<T>, Function<T,R>, Predicate<T>, Supplier<T>, UnaryOperator<T> BinaryOperator<T> и их Bi – формы

+ **Predicate<T>** - проверяет соблюдение некоторого условия.
Если оно соблюдается, то возвращается значение true. В качестве параметра лямбда-выражение принимает объект типа T
+ **BinaryOperator<T>** - принимает в качестве параметра два объекта типа T, выполняет над ними бинарную операцию
и возвращает ее результат также в виде объекта типа T
+ **UnaryOperator<T>** - принимает в качестве параметра объект типа T,
выполняет над ними операции и возвращает результат операций в виде объекта типа T
+ **Function<T,R>** - представляет функцию перехода от объекта типа T к объекту типа R
+ **Consumer<T>** - выполняет некоторое действие над объектом типа T, при этом ничего не возвращая
+ **Supplier<T>** - принимает никаких аргументов, но должен возвращать объект типа T
    
[к оглавлению](#FP-Labmda-Stream-API)

## Что такое функции высшего порядка
Функции высшего порядка принимают другие функции в качестве своих параметров или возвращают другие функции в качестве своих результатов.
У языка Java — возможно, последнего среди популярных языков — наконец-то появились функции высшего порядка в форме т. н. лямбда-выражений.
	
Основная идея: функции имеют тот же статус, что и другие объекты данных.

[к оглавлению](#FP-Labmda-Stream-API)

## Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка
	
	Predicate — функциональный интерфейс для проверки соблюдения некоторого условия. 
	Если условие соблюдается, возвращает true, иначе — false:

@FunctionalInterface
	
public interface Predicate<T> {
	
   boolean test(T t);
	
}
	
	
	Consumer (с англ. — “потребитель”) — функциональный интерфейс, который принимает в качестве 
	входного аргумента объект типа T, совершает некоторые действия, но при этом ничего не возвращает:

@FunctionalInterface
	
public interface Consumer<T> {
	
   void accept(T t);
	
}
	
	
	Supplier (с англ. — поставщик) — функциональный интерфейс, который не принимает никаких аргументов, 
	но возвращает некоторый объект типа T:

@FunctionalInterface
	
public interface Supplier<T> {
	
   T get();
	
}
	
	
	Function — этот функциональный интерфейс принимает аргумент T и приводит его к объекту типа R, 
	который и возвращается как результат:

@FunctionalInterface
	
public interface Function<T, R> {
	
   R apply(T t);
	
}
	
	
	UnaryOperator — функциональный интерфейс, принимает в качестве параметра объект типа T, 
	выполняет над ним некоторые операции и возвращает результат операций в виде объекта того же типа T:

@FunctionalInterface
	
public interface UnaryOperator<T> {
	
   T apply(T t);
	
}
	
	А таким, что многие методы Stream работают именно с данными функциональными интерфейсами. 
	Давайте рассмотрим, как можно применять функциональные интерфейсы в методах Stream.
Метод с Predicate
Для примера возьмем метод класса Stream — filter, который в качестве аргумента принимает Predicate и 
	возвращает Stream только с теми элементами, которые удовлетворяют условию Predicate.

В контексте Stream-а это означает, что он пропускает только те элементы, которые возвращают true при 
	использовании их в методе test интерфейса Predicate. 

Вот как будет выглядеть наш пример для Predicate, но уже для фильтра элементов в Stream:

public static void main(String[] args) {
	
   List<Integer> evenNumbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8)
	
           .filter(x -> x % 2==0)
	
           .collect(Collectors.toList());
	
}

В итоге список evenNumbers будет состоять из элементов {2, 4, 6, 8}.

И, как мы помним, collect будет собирать все элементы в некоторую коллекцию: в нашем случае — в List.
Метод с Consumer
Одним из методом в Stream, который использует функциональный интерфейс Consumer, является метод peek.

Так будет выглядеть наш пример для Consumer в Stream:

public static void main(String[] args) {
	
   List<String> peopleGreetings = Stream.of("Elena", "John", "Alex", "Jim", "Sara")
	
           .peek(x -> System.out.println("Hello " + x + " !!!"))
	
           .collect(Collectors.toList());
	
}

Вывод в консоль:


Hello Elena !!!
Hello John !!!
Hello Alex !!!
Hello Jim !!!
Hello Sara !!!

Но так как метод peek работает с Consumer, модификации строк в Stream не произойдет, а сам 
	peek вернет Stream с изначальными элементами: такими, какими они ему пришли.

Поэтому список peopleGreetings будет состоять из элементов "Elena", "John", "Alex", "Jim", "Sara".

Также есть часто используемый метод foreach, который аналогичен методу peek, 
	но разница состоит в том, что он конечный — терминальный.
Метод с Supplier
Примером метода в Stream, использующего функциональный интерфейс Supplier, 
	является generate, который генерирует бесконечную последовательность на основе переданного ему функционального интерфейса.

Воспользуемся нашим примером Supplier для вывода в консоль пяти случайных имен:

public static void main(String[] args) {
	
   ArrayList<String> nameList = new ArrayList<>();
	
   nameList.add("Elena");
	
   nameList.add("John");
	
   nameList.add("Alex");
	
   nameList.add("Jim");
	
   nameList.add("Sara");

   Stream.generate(() -> {
	
       int value = (int) (Math.random() * nameList.size());
	
       return nameList.get(value);
	
   }).limit(5).forEach(System.out::println);
	
}

И вот какой мы получим вывод в консоль:


John
Elena
Elena
Elena
Jim

Здесь мы использовали метод limit(5), чтобы задать ограничение методу generate, 
	иначе программа выводила бы рандомные имена в консоль бесконечно.
Метод с Function
Типичный пример метода в Stream c аргументом Function — метод map, который принимает 
	элементы одного типа, что-то с ними делает и передает дальше, но это уже могут быть элементы другого типа.

Как может выглядеть пример с Function в Stream:

public static void main(String[] args) {
	
   List<Integer> values = Stream.of("32", "43", "74", "54", "3")
	
           .map(x -> Integer.valueOf(x)).collect(Collectors.toList());
	
}

В итоге мы получаем список чисел, но уже в формате Integer.
Метод с UnaryOperator
В качестве метода, использующего UnaryOperator как аргумент, возьмем метод класса Stream — iterate.

Данный метод схож с методом generate: он также генерирует бесконечную последовательность но имеет два аргумента:
первый — элемент, с которого начинается генерация последовательности;
второй — UnaryOperator, который указывает принцип генерации новых элементов с первого элемента.
Как будет выглядеть наш пример UnaryOperator, но в методе iterate:

public static void main(String[] args) {
	
   Stream.iterate(9, x -> x * x)
	
           .limit(4)
	
           .forEach(System.out::println);
	
}

Запустив, мы получим вывод в консоль:


9
81
6561
43046721

То есть каждый наш элемент умножен на самого себя, и так для первых четырёх чисел.
	

[к оглавлению](#FP-Labmda-Stream-API)

## Что такое ссылки на методы
Начиная с JDK 8 в Java можно в качестве параметра в метод передавать ссылку на другой метод.
В принципе данный способ аналогичен передаче в метод лямбда-выражения.
Ссылка на метод передается в виде имя_класса::имя_статического_метода (если метод статический)
или объект_класса::имя_метода (если метод нестатический).

[к оглавлению](#FP-Labmda-Stream-API)

## Что такое ссылки на конструкторы
Можно в качестве параметров использовать конструкторы: название_класса::new
При использовании конструкторов методы функциональных интерфейсов должны принимать тот же список параметров,
что и конструкторы класса, и должны возвращать объект данного класса.

[к оглавлению](#FP-Labmda-Stream-API)

## Расскажите о зоне видимости переменных в lamdba - выражениях

	
	Существует три очень похожих типа захвата переменных:

захват локальной переменной
захват переменной экземпляра
захват статической переменной
Синтаксис почти идентичен тому, как вы могли бы получить доступ к этим переменным из любой 
	другой функции, но условия, при которых вы можете это сделать, отличаются.

Вы можете получить доступ к локальной переменной только в том случае , если она фактически 
	окончательная , что означает, что она не изменяет свое значение после присвоения. 
	Это не обязательно должно быть явно объявлено как окончательное, но желательно сделать 
	это, чтобы избежать путаницы. Если вы используете его в лямбда-функции, а затем измените его значение, компилятор начнет ныть.

Причина, по которой вы не можете этого сделать, заключается в том, что лямбда-код не может 
	надежно ссылаться на локальную переменную, поскольку она может быть уничтожена до 
	выполнения лямбды. Из-за этого он делает глубокую копию . Изменение локальной 
	переменной может привести к некоторому запутанному поведению, так как программист 
	может ожидать, что значение в лямбде изменится, поэтому, чтобы избежать путаницы, 
	это явно запрещено.
	
	Когда дело доходит до переменных экземпляра , если ваша лямбда находится в том же 
	классе, что и переменная, к которой вы обращаетесь, вы можете просто использовать 
	это.поле для доступа к полю в этом классе. Кроме того, поле не обязательно должно 
	быть окончательным и может быть изменено позже в ходе программы.

Это связано с тем, что если лямбда-код определен в классе, он создается вместе с этим классом 
	и привязан к этому экземпляру класса и, таким образом, может легко ссылаться на 
	значение нужного ему поля.

Статические переменные записываются так же, как переменные экземпляра, за исключением того
	факта, что вы не использовали бы это для ссылки на них. Они могут быть изменены и 
	не обязательно должны быть окончательными по тем же причинам.
	

[к оглавлению](#FP-Labmda-Stream-API)

## Как быть в ситуации, если внутри lamdba - выражении операторы могут выкинуть исключение

	В лямбда-выражениях нельзя использовать методы, которые могут выбросить исключения.

Поток данных не может прерываться.

А как быть? Не использовать лямбда-выражения с исключениями.

[к оглавлению](#FP-Labmda-Stream-API)

## Что такое Stream API
Начиная с JDK 8 в Java появился новый API - Stream API. Его задача - упростить работу с наборами данных, в частности,
упростить операции фильтрации, сортировки и другие манипуляции с данными. Вся основная функциональность данного API
сосредоточена в пакете java.util.stream. Ключевым понятием в Stream API является поток данных.
Поток представляет канал передачи данных из источника данных.
Причем в качестве источника могут выступать как файлы, так и массивы и коллекции.
Одной из отличительных черт Stream API является применение лямбда-выражений.
При работе со Stream API важно понимать, что все операции с потоками бывают либо терминальными (terminal),
либо промежуточными (intermediate). Промежуточные операции возвращают трансформированный поток.
Например, выше в примере метод filter принимал поток чисел и возвращал уже преобразованный поток,
в котором только числа больше 0. К возвращенному потоку также можно применить ряд промежуточных операций.
Конечные или терминальные операции возвращают конкретный результат.

[к оглавлению](#FP-Labmda-Stream-API)

## Расскажите, как шаблон проектирования используется внутри Stream API

	
	Для построения потоков при работе со Stream используется шаблон проектирования Builder 
	(в переводе на русский - Строитель). Давайте разберемся что это за шаблон, как он 
	реализуется и для чего может быть применен.

Строитель - это порождающий шаблон проектирования, который позволяет создавать сложные объекты 
	пошагово. Строитель позволяет использовать один и тот же код построения объекта для 
	получения разных представлений объектов. Он предлагает вынесение конструирования объекта 
	за пределы его собственного класса (или за счет вложенного статического класса), поручив 
	это дело отдельным объектам, которые и называются строителями.

Шаблон предлагает разбить процесс конструирования объекта на отдельные шаги (например для нашего 
	класса - присвоитьИмя, присвоитьВозраст и т.д.). Чтобы создавать объекты таким образом, 
	нам нужно поочередно вызывать методы строителя. При этом нам не нужно запускать все шаги, 
	а только те, которые нужны для производства объекта определенной конфигурации. 

[к оглавлению](#FP-Labmda-Stream-API)

## Что делает метод filter
Представляет промежуточную операцию. Он принимает в качестве параметра некоторое условие в виде 
	объекта Predicate<T>
и возвращает новый поток из элементов, которые удовлетворяют этому условию

[к оглавлению](#FP-Labmda-Stream-API)

## Что делает метод map
Отображение или маппинг позволяет задать функцию преобразования одного объекта в другой,
то есть получить из элемента одного типа элемент другого типа.
Для отображения используется метод map, который имеет следующее определение:
```java <R> Stream<R> map(Function<? super T, ? extends R> mapper) ```
Передаваемая в метод map функция задает преобразование от объектов типа T к типу R.
И в результате возвращается новый поток с преобразованными объектами.

[к оглавлению](#FP-Labmda-Stream-API)

## Что делает метод flatMap
Плоское отображение выполняется тогда, когда из одного элемента нужно получить несколько.
Данную операцию выполняет метод flatMap:
```java <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper) ```
Например, в примере выше мы выводим название телефона и его цену.
Но что, если мы хотим установить для каждого телефона цену со скидкой и цену без скидки.
То есть из одного объекта Phone нам надо получить два объекта с информацией, например, в виде строки.
Для этого применим flatMap:
```java
    Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000), new Phone("Lumia 950", 45000),
                    new Phone("Samsung Galaxy S 6", 40000));

    phoneStream
        .flatMap(p->Stream.of(
                String.format("название: %s  цена без скидки: %d", p.getName(), p.getPrice()),
                String.format("название: %s  цена со скидкой: %d", p.getName(), p.getPrice() - (int)(p.getPrice()*0.1))
        ))
        .forEach(s->System.out.println(s));
```
[к оглавлению](#FP-Labmda-Stream-API)

## Что делает метод collect
Преобразует поток в коллекцию. Мы можем написать свою реализацию функции, однако Java уже предоставляет
ряд встроенных функций, определенных в классе Collectors:
+ toList(): преобразование к типу List
+ toSet(): преобразование к типу Set
+ toMap(): преобразование к типу Map

[к оглавлению](#FP-Labmda-Stream-API)

## Что делает метод reduce
Позволяет выполнять агрегатные функции на всей коллекцией и возвращать один результат
Метод reduce выполняет терминальные операции сведения, возвращая некоторое значение - результат операции.
Он имеет следующие формы:
+ Optional<T> reduce(BinaryOperator<T> accumulator)
+ T reduce(T identity, BinaryOperator<T> accumulator)
+ U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)

Первая форма возвращает результат в виде объекта Optional<T>. Например, вычислим произведение набора чисел:
```java
Stream<Integer> numbersStream = Stream.of(1,2,3,4,5,6);
Optional<Integer> result = numbersStream.reduce((x,y)->x*y);
System.out.println(result.get()); // 720
```

Объект BinaryOperator<T> представляет функцию, которая принимает два элемента и выполняет над ними некоторую операцию,
возвращая результат. При этом метод reduce сохраняет результат и затем опять же применяет к этому результату
и следующему элементу в наборе бинарную операцию.

Если нам надо, чтобы первым элементом в наборе было какое-то определенное значение, то мы можем использовать вторую
версию метода reduce(), которая в качестве первого параметра принимает T identity.
Этот параметр хранит значение, с которого будет начинаться цепочка бинарных операций. Например:

```java
Stream<String> wordsStream = Stream.of("мама", "мыла", "раму");
String sentence = wordsStream.reduce("Результат:", (x,y)->x + " " + y);
System.out.println(sentence); // Результат: мама мыла раму
```

Допустим мы хотим найти сумму цен тех телефонов, у которых цена меньше определенного значения.
Для этого используем третью версию метода reduce:

```java
    Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000),
                new Phone("Lumia 950", 45000),
                new Phone("Samsung Galaxy S 6", 40000),
                new Phone("LG G 4", 32000));

    int sum = phoneStream.reduce(0,
                (x,y)-> {
                        if(y.getPrice()<50000)
                            return x + y.getPrice();
                        else
                            return x + 0;
                },
                (x, y)->x+y);

    System.out.println(sum); // 117000
```

[к оглавлению](#FP-Labmda-Stream-API)

## Что делает метод findFirst
Возвращает первый элемент из стрима (возвращает Optional)

[к оглавлению](#FP-Labmda-Stream-API)

## Возможно ли прервать выполнение потока по аналогии с break
Stream может выполнятся в несколько параллельных потоков, поэтому прерывание может привести к некорректным результатам.
В Java 9 можно использовать ```java takeWhile ```.
Лучше использовать итератор:
```java
    Iterator<BuyOrderType> iter = market.buyOrders() // replace BuyOrderType with correct type here
                .stream()
                .filter(buyOrder -> buyOrder.price >= sellOrder.price)
                .sorted(BY_ASCENDING_PRICE).iterator();
    while (iter.hasNext()) {
        BuyOrderType buyOrder = iter.next()  // replace BuyOrderType with correct type here
        double tradeVolume = Math.min(buyOrder.quantity, sellOrder.quantity);
        double price = buyOrder.price;

        buyOrder.quantity -= tradeVolume;
        sellOrder.quantity -= tradeVolume;

        Trade trade = new Trade.Builder(market, price, tradeVolume, Trade.Type.SELL).build();
        CommonUtil.convertToJSON(trade);

        if (sellOrder.quantity == 0) {
            System.out.println("order fulfilled");
            break;
        }
    }
```

[к оглавлению](#FP-Labmda-Stream-API)

## Возможно ли пропустить элемент потока по аналогии с continue
Вместо этого можно использовать return или filter
```java
    public static void main(String[] args) {
        ArrayList<String> stringList = new ArrayList<>();
        stringList.add("a");
        stringList.add("b");
        stringList.add("c");

        stringList.stream().forEach(str -> {
            if (str.equals("b")) return; // only skips this iteration.

            System.out.println(str); // a c
        });
    }
```
[к оглавлению](#FP-Labmda-Stream-API)

## Что такое Optional
В релизе Java 8 появился новый класс Optional призванный помочь разработчикам в обработке NullPointerException.

```java
    //Пустой Optional объект
    Optional<Person> optionalPerson = Optional.empty();

    //Optional объект с ненулевым значением
    Optional<Person> optionalNonNull = Optional.of(somePerson);

    //Optional объект с возможностью нулевого значения
    Optional<Person> optionalNullable = Optional.ofNullable(somePerson);
```

Метод ifPresent() позволяет также устранить некоторую избыточность кода, следующего вида:
```java
     if(person != null) {
    	System.out.println(person);
     }
```

Те же действия, но с использованием Optional:
```java  person.ifPresent(System.out::println); ```

orElse(), orElseThrow():
Как было раньше:
```java Person personNew = person != null ? person : new Person(); ```

То же самое, но с использованием Optional:
```java Person personNew = person.orElse(new Person()); ```
Или, если не хотим создавать объект, можно выбросить исключение:
```java Person personNewThrow = person.orElseThrow(Exception::new); ```

[к оглавлению](#FP-Labmda-Stream-API)

## Перечислите методы Optional
+ Optional.empty() - возвращает Optional с null внутри
+ Optional.of(T value) - возвращает Optional с нe null значением внутри
+ Optional.ofNullable(T value) - возвращает Optional который может содержать null значение внутри

Дальше мы рассмотрим методы конкретного объекта optional.
+ filter(Predicate<? super T> predicate) - Этот метод дает возможность отфильтровать значение опционального типа.
Мы передаем ему в параметр Predicat (это стандартный функциональный интерфейс),
он возвращает булево значение, если значение true, то возвращается этот же опционал, если значение false,
то возвращается пустой опционал (Optional.empty())
+ flatMap(Function<? super T,Optional<U>> mapper) - Этот метод можно применить для изменения значения установленного
в опционале. Функция которая передается в метод flatMap должна возвращать опционал.
Если значение не установлено, вернется Optional.empty()
+ get() - Этот метод возвращает значение из опционала. Нужно аккуратно использовать этот метод,
так как он может бросить исключение NoSuchElementException, если значение в опционале равно null.
Чтобы безопасно использовать этот метод перед его вызовом надо вызвать метод isPresent()
+ ifPresent(Consumer<? super T> consumer) - Этот метод исполняет Consumer функциональный интерфейс
если значение в опционале присутствует
+ isPresent() - Возвращает булево значение true если в опционале значение есть и возвращает false если в опционале значение null
+ orElse(T other) - Этот метод используется для того, чтобы установить значение по-умолчанию в том случае
если значение в опционале отсутствует
+ orElseThrow(Supplier<? extends X> exceptionSupplier) - Этот метод используется для того, чтобы бросить исключение
которое передается в метод orElseThrow если значения в опционале не установлено
+ orElseGet(Supplier<? extends T> other) - Этот метод полный аналог метода orElse,
только принимает в себя функциональный интерфейс который должен вернуть значение

[к оглавлению](#FP-Labmda-Stream-API)

## Расскажите про фабричные методы List.of, Set.of, Map.of
С приходом Java 9 создавать immutable коллекции намного проще.

+ List
Создание списка выглядит так:
```java List<Integer> nums = List.of(1,2,3,4,5); ```
Метод of() в интерфейсе List  перегружен и принимает от одного до десяти элементов. Если хотим создать коллекцию с более чем десятью элементами, тогда будет использоваться перегруженный метод с varargs
```java static <E> List<E> of(E... elements) ```
Сделано это с целью оптимизации, так как  при каждом вызове метода c varargs будет создаваться новый массив

+ Set
```java Set<String> questions = Set.of("What?", "Where?", "When?"); ```
Set также имеет перегруженные методы, но в отличии от List, если передать дубликат в метод of(), то получим исключение
```java Set<String> questions = Set.of("What?", "What?"); // IllegalArgumentException: duplicate element: What? ```

+ Map
```java Map<String, String> params = Map.of("Name:", "John", "Surname:", "Snow", "Status:", "Unmarried"); ```
Последовательности идут парами key, value. Всего таких пар может быть 10, в отличии от List и Set.
Если в последовательности будут повторения ключей - получим исключение
```java Map.of("уникально", "наверняка", "уникально", "но это не точно"); // IllegalArgumentException: duplicate key: уникально ```

+ Вышеупомянутые коллекции нельзя изменить, при попытке получим UnsupportedOperationException;
+ В метод of() нельзя передать null, во всех коллекциях получим NullPointerException;
+ Метод of() не создает привычные ArrayList, HashSet или HashMap. В Java 9 были созданы специальные ImmutableCollections которые и возвращаются;
+ ImmutableCollections являются сериализуемыми, если содержимое тоже является сериализуемым;

[к оглавлению](#FP-Labmda-Stream-API)

## Для чего используется ключевое слово var
Одним из самых интересных нововведений Java 10 безусловно является вывод типа локальной переменной (JEP 286).
Это дает вам возможность сократить объявления переменных используя новое ключевое слово var
При обработке var, компилятор просматривает правую часть объявления,
так называемый инициализатор и использует его тип для переменной.

[к оглавлению](#FP-Labmda-Stream-API)
    
## В какие случаях можно использовать var    
var - может использоваться только в сочетании с данными.

[к оглавлению](#FP-Labmda-Stream-API)
